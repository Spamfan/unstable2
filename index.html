<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Framework 5: Collision Logic Test</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #333; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; }
        
        #debug-overlay {
            position: fixed; top: 10px; left: 10px;
            color: #00FF00; font-family: monospace; font-size: 16px; font-weight: bold;
            background: rgba(0,0,0,0.6); padding: 8px; pointer-events: none; border-radius: 4px;
        }

        #joystick-zone {
            position: fixed; bottom: 50px; left: 50px;
            width: 150px; height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            touch-action: none;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="debug-overlay">
        FPS: <span id="fps-cur">0</span><br>
        Min: <span id="fps-min" style="color: #ff4444;">0</span><br>
        Max: <span id="fps-max" style="color: #44ff44;">0</span><br>
        Test: Collision Math (50 Bullets vs 2000 Tanks)
    </div>
    <canvas id="gameCanvas"></canvas>
    <div id="joystick-zone"><div id="joystick-knob"></div></div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // State
    let width, height;
    const gridSize = 40;
    const worldSize = 4000;
    let camera = { x: 0, y: 0 };
    
    let player = { x: 2000, y: 2000, width: 35, height: 35, speed: 8, angle: 0, turretAngle: 0 };
    let joystick = { active: false, dx: 0, dy: 0 };
    
    // GENERATE 2000 "TANKS"
    let worldObjects = [];
    function generateWorld() {
        for(let i=0; i<2000; i++) {
            worldObjects.push({
                x: Math.random() * worldSize,
                y: Math.random() * worldSize,
                angle: Math.random() * Math.PI * 2,
                turretAngle: Math.random() * Math.PI * 2,
                width: 35,
                height: 35,
                color: Math.random() > 0.5 ? '#991b1b' : '#7f1d1d'
            });
        }
    }
    generateWorld();

    // GENERATE 50 BULLETS (Simulated)
    let bullets = [];
    function spawnBullets() {
        for(let i=0; i<50; i++) {
            bullets.push({
                x: Math.random() * worldSize,
                y: Math.random() * worldSize,
                dx: (Math.random() - 0.5) * 10,
                dy: (Math.random() - 0.5) * 10
            });
        }
    }
    spawnBullets();

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    // --- SPATIAL GRID (The Math Engine) ---
    class SpatialGrid {
        constructor(width, height, cellSize) {
            this.cellSize = cellSize;
            this.cells = new Map();
        }
        getKey(x, y) { return `${x},${y}`; }
        add(obj) {
            const startX = Math.floor(obj.x / this.cellSize);
            const startY = Math.floor(obj.y / this.cellSize);
            const key = this.getKey(startX, startY);
            if (!this.cells.has(key)) this.cells.set(key, []);
            this.cells.get(key).push(obj);
        }
        getNearby(x, y) {
            const nearby = [];
            const cx = Math.floor(x / this.cellSize);
            const cy = Math.floor(y / this.cellSize);
            for(let i = cx-1; i<=cx+1; i++) {
                for(let j = cy-1; j<=cy+1; j++) {
                    const key = this.getKey(i, j);
                    if(this.cells.has(key)) nearby.push(...this.cells.get(key));
                }
            }
            return nearby;
        }
    }

    // Joystick Logic
    const joyZone = document.getElementById('joystick-zone');
    const joyKnob = document.getElementById('joystick-knob');
    const joyRect = joyZone.getBoundingClientRect();
    const joyCenter = { x: joyRect.left + joyRect.width/2, y: joyRect.top + joyRect.height/2 };

    joyZone.addEventListener('touchstart', (e) => { e.preventDefault(); joystick.active = true; updateJoystick(e.changedTouches[0]); }, { passive: false });
    joyZone.addEventListener('touchmove', (e) => { e.preventDefault(); if(joystick.active) updateJoystick(e.changedTouches[0]); }, { passive: false });
    const endJoystick = (e) => { e.preventDefault(); joystick.active = false; joystick.dx = 0; joystick.dy = 0; joyKnob.style.transform = `translate(-50%, -50%)`; };
    joyZone.addEventListener('touchend', endJoystick); joyZone.addEventListener('touchcancel', endJoystick);

    function updateJoystick(touch) {
        const maxDist = 50;
        let dx = touch.clientX - joyCenter.x;
        let dy = touch.clientY - joyCenter.y;
        const dist = Math.hypot(dx, dy);
        const visualDist = Math.min(dist, maxDist);
        const angle = Math.atan2(dy, dx);
        joyKnob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*visualDist}px), calc(-50% + ${Math.sin(angle)*visualDist}px))`;
        if (dist > 10) { joystick.dx = dx / dist; joystick.dy = dy / dist; } else { joystick.dx = 0; joystick.dy = 0; }
    }

    function drawTank(t) {
        ctx.save();
        ctx.translate(t.x + t.width / 2, t.y + t.height / 2);
        ctx.save();
        ctx.rotate(t.angle);
        ctx.lineWidth = 3; ctx.strokeStyle = 'black'; ctx.fillStyle = "#4A5568";
        ctx.strokeRect(-t.width / 2, -t.height / 2, t.width, t.height);
        ctx.fillRect(-t.width / 2, -t.height / 2, t.width, t.height);
        ctx.fillStyle = t.color || "#3b82f6"; 
        ctx.strokeRect(-t.width / 2 * 0.8, -t.height / 2 * 0.8, t.width * 0.8, t.height * 0.8);
        ctx.fillRect(-t.width / 2 * 0.8, -t.height / 2 * 0.8, t.width * 0.8, t.height * 0.8);
        ctx.restore();
        ctx.rotate(t.turretAngle);
        ctx.fillStyle = "#718096";
        ctx.strokeRect(-t.width/4, -t.height/8, t.width/2, t.height/4);
        ctx.fillRect(-t.width/4, -t.height/8, t.width/2, t.height/4);
        ctx.restore();
    }

    // --- LOOP ---
    let lastTime = performance.now();
    let frames = 0;
    let lastFpsTime = lastTime;
    let minFps = 60;
    let maxFps = 0;

    function loop(now) {
        frames++;
        const delta = now - lastTime;
        const instantFps = 1000 / delta;
        lastTime = now;

        if (instantFps < minFps && frames > 5) minFps = instantFps;
        if (instantFps > maxFps) maxFps = instantFps;

        if (now - lastFpsTime >= 1000) {
            document.getElementById('fps-cur').textContent = Math.round(frames);
            document.getElementById('fps-min').textContent = Math.round(minFps);
            document.getElementById('fps-max').textContent = Math.round(maxFps);
            frames = 0; minFps = 60; maxFps = 0; lastFpsTime = now;
        }

        // --- THE COLLISION STRESS TEST ---
        
        // 1. Create Grid
        let trashGrid = new SpatialGrid(worldSize, worldSize, 200);
        for(const obj of worldObjects) {
            trashGrid.add(obj);
        }

        // 2. Simulate Bullet Updates & Collisions
        for (let b of bullets) {
            b.x += b.dx; b.y += b.dy;
            if(b.x < 0 || b.x > worldSize) b.dx *= -1;
            if(b.y < 0 || b.y > worldSize) b.dy *= -1;

            // The Expensive Query
            const nearby = trashGrid.getNearby(b.x, b.y);
            for(const t of nearby) {
                // The Expensive Math
                const dist = Math.hypot(b.x - (t.x + t.width/2), b.y - (t.y + t.height/2));
                if(dist < 20) {
                    // Hit logic would go here
                }
            }
        }

        // Update Player
        if (joystick.active) {
            player.x += joystick.dx * player.speed;
            player.y += joystick.dy * player.speed;
            player.angle = Math.atan2(joystick.dy, joystick.dx);
            player.turretAngle = player.angle; 
        }
        camera.x = player.x - width / 2;
        camera.y = player.y - height / 2;

        // Draw
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        const startCol = Math.floor(camera.x / gridSize);
        const endCol = startCol + (width / gridSize) + 1;
        const startRow = Math.floor(camera.y / gridSize);
        const endRow = startRow + (height / gridSize) + 1;
        for (let c = startCol; c <= endCol; c++) {
            for (let r = startRow; r <= endRow; r++) {
                ctx.fillStyle = (c + r) % 2 === 0 ? '#48D43B' : '#3eb532';
                ctx.fillRect(c * gridSize, r * gridSize, gridSize, gridSize);
            }
        }

        for (const obj of worldObjects) {
            drawTank(obj);
        }
        drawTank(player);
        
        // Draw Bullets
        ctx.fillStyle = 'yellow';
        for(const b of bullets) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, 5, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.restore();
        requestAnimationFrame(loop);
    }

    requestAnimationFrame(loop);

</script>
</body>
</html>